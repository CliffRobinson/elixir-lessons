defmodule PhoenixMemory.MemoryServer do
  use GenServer

  def start_link(arg_opts \\ []) do
    initialState = init_state()
    opts = Keyword.merge(arg_opts, name: __MODULE__)
    IO.puts("This is the memory server, it am starts!")
    # Is this how we do options? Seems inelegant
    GenServer.start_link(__MODULE__, initialState, opts)
  end

  def init(state) do
    {:ok, state}
  end

  def do_a_thing() do
    GenServer.call(__MODULE__, {:do_a_thing})
  end

  def get_a_thing(thing) do
    GenServer.call(__MODULE__, {:get_a_thing, thing})
  end

  def get_state() do
    GenServer.call(__MODULE__, {:get_state})
  end

  def handle_call({:do_a_thing}, _from, state) do
    server_string = "This is a string generated by the server"

    IO.puts("Hello i am the server and I am printing server_string")
    IO.puts(server_string)

    {:reply, server_string, state}
  end

  def handle_call({:get_a_thing, thing}, _from, state) do
    IO.puts("I am the server and I got a thing from the client!!! It is:")
    IO.inspect(thing)
    {:reply, :ok, [state | thing]}
  end

  def handle_call({:get_state}, _from, state) do
    {:reply, state, state}
  end

  def init_state() do
    board = [
      "A","A","B","B","C","C","D","D","E","E","F","F","G","G","H","H","I","I","J","J"
    ]
    |> Enum.shuffle()
    |> Enum.with_index(fn el, index -> {index + 1, false, el} end)

    %{:guesses => 30, :board => board}
  end
end

# MemoryServer.start_link()
